'use strict';

function bindNot(fn) {
    return (...args) => !fn(...args);
}

function isNumeric(value) {
    const str = String(value);
    const num = Number(value);
    const result = !isNaN(parseFloat(str)) && !isNaN(Number(value)) && isFinite(num);
    return Boolean(result);
}
const isNotNumeric = bindNot(isNumeric);

function numberEquals(value, eq) {
    return isNumeric(value) && isNumeric(eq) && Number(value) === Number(eq);
}
const numberNotEquals = bindNot(numberEquals);

function lengthEquals(value, arg1) {
    return numberEquals(value.length, arg1);
}
const lengthNotEquals = bindNot(lengthEquals);

function greaterThan(value, gt) {
    return isNumeric(value) && isNumeric(gt) && Number(value) > Number(gt);
}

function longerThan(value, arg1) {
    return greaterThan(value.length, arg1);
}

/**
 * Creates a cache function
 */
function createCache(maxSize = 1) {
    const cacheStorage = [];
    const cache = (deps, cacheAction) => {
        const cacheHit = cache.get(deps);
        // cache hit is not null
        if (cacheHit)
            return cacheHit[1];
        const result = cacheAction();
        cacheStorage.unshift([deps.concat(), result]);
        if (longerThan(cacheStorage, maxSize))
            cacheStorage.length = maxSize;
        return result;
    };
    // invalidate an item in the cache by its dependencies
    cache.invalidate = (deps) => {
        const index = findIndex(deps);
        if (index > -1)
            cacheStorage.splice(index, 1);
    };
    // Retrieves an item from the cache.
    cache.get = (deps) => cacheStorage[findIndex(deps)] || null;
    return cache;
    function findIndex(deps) {
        return cacheStorage.findIndex(([cachedDeps]) => lengthEquals(deps, cachedDeps.length) &&
            deps.every((dep, i) => dep === cachedDeps[i]));
    }
}

function isNull(value) {
    return value === null;
}
const isNotNull = bindNot(isNull);

function isUndefined(value) {
    return value === undefined;
}
const isNotUndefined = bindNot(isUndefined);

function isNullish(value) {
    return isNull(value) || isUndefined(value);
}
const isNotNullish = bindNot(isNullish);

function asArray(possibleArg) {
    return [].concat(possibleArg);
}

function callEach(arr) {
    return arr.forEach(fn => fn());
}

/**
 * A safe hasOwnProperty access
 */
function hasOwnProperty(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function isFunction(value) {
    return typeof value === 'function';
}

function isPromise(value) {
    return !!value && isFunction(value.then);
}

function optionalFunctionValue(value, ...args) {
    return isFunction(value) ? value(...args) : value;
}

var assign = Object.assign;

function defaultTo(value, defaultValue) {
    var _a;
    return (_a = optionalFunctionValue(value)) !== null && _a !== void 0 ? _a : optionalFunctionValue(defaultValue);
}

function invariant(condition, 
// eslint-disable-next-line @typescript-eslint/ban-types
message) {
    if (condition) {
        return;
    }
    // If message is a string object (rather than string literal)
    // Throw the value directly as a string
    // Alternatively, throw an error with the message
    throw message instanceof String
        ? message.valueOf()
        : new Error(message ? optionalFunctionValue(message) : message);
}

function isStringValue(v) {
    return String(v) === v;
}

function either(a, b) {
    return !!a !== !!b;
}

function isBoolean(value) {
    return !!value === value;
}

function deferThrow(message) {
    setTimeout(() => {
        throw new Error(message);
    }, 0);
}

const EVENT_WILDCARD = '*';
function createBus() {
    const listeners = {};
    return {
        emit(event, data) {
            getListeners(event)
                .concat(getListeners(EVENT_WILDCARD))
                .forEach(handler => {
                handler(data);
            });
        },
        on(event, handler) {
            listeners[event] = getListeners(event).concat(handler);
            return {
                off() {
                    listeners[event] = getListeners(event).filter(h => h !== handler);
                },
            };
        },
    };
    function getListeners(event) {
        return listeners[event] || [];
    }
}

var bus = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createBus: createBus
});

/**
 * @returns a unique numeric id.
 */
const seq = genSeq();
function genSeq(namespace) {
    return ((n) => () => `${namespace ? namespace + '_' : ''}${n++}`)(0);
}

function mapFirst(array, callback) {
    let broke = false;
    let breakoutValue = null;
    for (let i = 0; i < array.length; i++) {
        callback(array[i], breakout, i);
        if (broke) {
            return breakoutValue;
        }
    }
    function breakout(conditional, value) {
        if (conditional) {
            broke = true;
            breakoutValue = value;
        }
    }
}

function isObject(v) {
    return typeof v === 'object' && !isNullish(v);
}

// The module is named "isArrayValue" since it
// is conflicting with a nested npm dependency.
// We may need to revisit this in the future.
function isArray(value) {
    return Boolean(Array.isArray(value));
}
const isNotArray = bindNot(isArray);

function isEmpty(value) {
    if (!value) {
        return true;
    }
    else if (hasOwnProperty(value, 'length')) {
        return lengthEquals(value, 0);
    }
    else if (isObject(value)) {
        return lengthEquals(Object.keys(value), 0);
    }
    return false;
}
const isNotEmpty = bindNot(isEmpty);

function isPositive(value) {
    return greaterThan(value, 0);
}

const regexp = /{(.*?)}/g;
function text(str, ...substitutions) {
    const first = substitutions[0];
    if (isObject(first)) {
        return str.replace(regexp, (placeholder, key) => {
            var _a;
            return `${(_a = first[key]) !== null && _a !== void 0 ? _a : placeholder}`;
        });
    }
    const subs = [...substitutions];
    return str.replace(regexp, placeholder => {
        return `${isEmpty(subs) ? placeholder : subs.shift()}`;
    });
}

const STATE_WILD_CARD = '*';
function StateMachine(machine) {
    let state = machine.initial;
    const api = { getState, initial, staticTransition, transition };
    return api;
    function getState() {
        return state;
    }
    function initial() {
        return machine.initial;
    }
    function transition(action, payload) {
        return (state = staticTransition(state, action, payload));
    }
    // eslint-disable-next-line complexity
    function staticTransition(from, action, payload) {
        var _a, _b, _c;
        const transitionTo = (_b = (_a = machine.states[from]) === null || _a === void 0 ? void 0 : _a[action]) !== null && _b !== void 0 ? _b : 
        // @ts-expect-error - This is a valid state
        (_c = machine.states[STATE_WILD_CARD]) === null || _c === void 0 ? void 0 : _c[action];
        let target = transitionTo;
        if (Array.isArray(target)) {
            const [, conditional] = target;
            if (!conditional(payload)) {
                return from;
            }
            target = target[0];
        }
        if (!target || target === from) {
            return from;
        }
        return target;
    }
}

function nonnullish(value, error) {
    invariant(!isNullish(value), error);
    return value;
}

function createTinyState(initialValue) {
    let value;
    resetValue();
    return () => [value, setValue, resetValue];
    function setValue(nextValue) {
        value = optionalFunctionValue(nextValue, value);
    }
    function resetValue() {
        setValue(optionalFunctionValue(initialValue));
    }
}

var tinyState = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createTinyState: createTinyState
});

// eslint-disable-next-line @typescript-eslint/ban-types
function StringObject(value) {
    return new String(optionalFunctionValue(value));
}

// eslint-disable-next-line @typescript-eslint/no-empty-function
function noop() { }

function all(...p) {
    return (value) => isEmpty(p)
        ? false
        : p.every(predicate => optionalFunctionValue(predicate, value));
}
function any(...p) {
    return (value) => isEmpty(p)
        ? false
        : p.some(predicate => optionalFunctionValue(predicate, value));
}

var Predicates = /*#__PURE__*/Object.freeze({
  __proto__: null,
  all: all,
  any: any
});

exports.Predicates = Predicates;
exports.StateMachine = StateMachine;
exports.StringObject = StringObject;
exports.asArray = asArray;
exports.assign = assign;
exports.bindNot = bindNot;
exports.bus = bus;
exports.cache = createCache;
exports.callEach = callEach;
exports.defaultTo = defaultTo;
exports.deferThrow = deferThrow;
exports.either = either;
exports.genSeq = genSeq;
exports.greaterThan = greaterThan;
exports.hasOwnProperty = hasOwnProperty;
exports.invariant = invariant;
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isEmpty = isEmpty;
exports.isFunction = isFunction;
exports.isNotArray = isNotArray;
exports.isNotEmpty = isNotEmpty;
exports.isNotNull = isNotNull;
exports.isNotNullish = isNotNullish;
exports.isNotNumeric = isNotNumeric;
exports.isNotUndefined = isNotUndefined;
exports.isNull = isNull;
exports.isNullish = isNullish;
exports.isNumeric = isNumeric;
exports.isObject = isObject;
exports.isPositive = isPositive;
exports.isPromise = isPromise;
exports.isStringValue = isStringValue;
exports.isUndefined = isUndefined;
exports.lengthEquals = lengthEquals;
exports.lengthNotEquals = lengthNotEquals;
exports.longerThan = longerThan;
exports.mapFirst = mapFirst;
exports.nonnullish = nonnullish;
exports.noop = noop;
exports.numberEquals = numberEquals;
exports.numberNotEquals = numberNotEquals;
exports.optionalFunctionValue = optionalFunctionValue;
exports.seq = seq;
exports.text = text;
exports.tinyState = tinyState;
//# sourceMappingURL=vest-utils.development.js.map
